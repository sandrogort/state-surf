#pragma once
// Generated by StateSurf minimal generator (v1 subset). C++11 header-only.
enum class {{ type_prefix }}State {
  {{ pseudo_initial }},
{% for state in states %}
  {{ state }},
{% endfor %}
  {{ pseudo_final }}
};

enum class {{ type_prefix }}Event {
{% for event in events %}
  {{ event }}{{ "," if not loop.last else "" }}
{% endfor %}
};

enum class {{ type_prefix }}GuardId {
{% for guard in guard_ids %}
  {{ guard }}{{ "," if not loop.last else "" }}
{% endfor %}
};

enum class {{ type_prefix }}ActionId {
{% for action in action_ids %}
  {{ action }}{{ "," if not loop.last else "" }}
{% endfor %}
};

inline void on_event({{ type_prefix }}State, {{ type_prefix }}Event) {}
inline void on_transition({{ type_prefix }}State, {{ type_prefix }}State, {{ type_prefix }}Event) {}

/**
 * @brief Deterministic state machine generated from a PlantUML model.
 *
 * The `Callbacks` type argument must provide:
 *   - `void on_entry({{ type_prefix }}State)` invoked on every state entry
 *   - `void on_exit({{ type_prefix }}State)` invoked on every state exit
 *   - `bool guard({{ type_prefix }}State, {{ type_prefix }}Event, {{ type_prefix }}GuardId)` to resolve guard conditions
 *   - `void action({{ type_prefix }}State, {{ type_prefix }}Event, {{ type_prefix }}ActionId)` for transition side-effects
 *
 * Hold a callbacks instance for any required application state and pass it
 * into the constructor. Call `start()` to trigger the initial transition (or
 * let the first `dispatch` call do it lazily), then drive the machine with
 * `dispatch({{ type_prefix }}Event)` values. Query `state()` and
 * `terminated()` to observe runtime status.
 */
template <typename Callbacks>
class {{ type_prefix }}Machine {
public:
  explicit {{ type_prefix }}Machine(Callbacks& callbacks) : callbacks_(callbacks) { reset(); }

  void reset() {
    terminated_ = false;
{% if reset_lines %}
{% for line in reset_lines %}
    {{ line }}
{% endfor %}
{% else %}
    (void)0;
{% endif %}
  }

  void start() {
    if (terminated_ || started_) return;
    started_ = true;
{% if has_start_target %}
    {{ start_transition_line }}
    {{ start_state_line }}
{% for line in start_lines %}
    {{ line }}
{% endfor %}
{% else %}
{% for line in fallback_lines %}
    {{ line }}
{% endfor %}
{% endif %}
  }

  {{ type_prefix }}State state() const { return s_; }
  bool terminated() const { return terminated_; }

  void dispatch({{ type_prefix }}Event e) {
    if (terminated_) return;
    if (!started_) {
      start();
      if (!started_) return;
    }
    on_event(s_, e);
    switch (s_) {
{% for state in state_cases %}
      case {{ state.case_label }}: {
{% if state.events %}
        switch (e) {
{% for event in state.events %}
          case {{ event.case_label }}: {
{% for line in event.lines %}
{{ line }}
{% endfor %}
          }
{% endfor %}
          default: return;
        }
{% else %}
        return;
{% endif %}
      }
{% endfor %}
      case {{ pseudo_initial_literal }}: {
        return;
      }
      case {{ pseudo_final_literal }}: {
        return;
      }
    }
  }

private:
  Callbacks& callbacks_;
  {{ type_prefix }}State s_;
  bool started_ = false;
  bool terminated_ = false;
};
