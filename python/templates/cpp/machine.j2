#pragma once
// Generated by StateSurf minimal generator (v1 subset). C++11 header-only.
#include <cstdint>

enum class {{ type_prefix }}State : {{ state_enum_type }} {
  {{ pseudo_initial }},
{% for state in states %}
  {{ state }},
{% endfor %}
  {{ pseudo_final }}
};

enum class {{ type_prefix }}Event : {{ event_enum_type }} {
{% for event in events %}
  {{ event }}{{ "," if not loop.last else "" }}
{% endfor %}
};

enum class {{ type_prefix }}GuardId : {{ guard_enum_type }} {
{% for guard in guard_ids %}
  {{ guard }}{{ "," if not loop.last else "" }}
{% endfor %}
};

enum class {{ type_prefix }}ActionId : {{ action_enum_type }} {
{% for action in action_ids %}
  {{ action }}{{ "," if not loop.last else "" }}
{% endfor %}
};

struct {{ type_prefix }}Transition {
  {{ type_prefix }}State from_state;
  {{ type_prefix }}State to_state;
};

inline void on_event({{ type_prefix }}State current_state, {{ type_prefix }}Event event) {
  (void)current_state;
  (void)event;
}

inline void on_transition(
  {{ type_prefix }}Transition transition,
  {{ type_prefix }}Event event
) {
  (void)transition;
  (void)event;
}

/**
 * @brief Deterministic state machine generated from a PlantUML model.
 *
 * The `Callbacks` type argument must provide:
 *   - `void on_entry({{ type_prefix }}State)` invoked on every state entry
 *   - `void on_exit({{ type_prefix }}State)` invoked on every state exit
 *   - `bool guard({{ type_prefix }}State, {{ type_prefix }}Event, {{ type_prefix }}GuardId)` to resolve guard conditions
 *   - `void action({{ type_prefix }}State, {{ type_prefix }}Event, {{ type_prefix }}ActionId)` for transition side-effects
 *
 * Hold a callbacks instance for any required application state and pass it
 * into the constructor. Call `start()` to trigger the initial transition (or
 * let the first `dispatch` call do it lazily), then drive the machine with
 * `dispatch({{ type_prefix }}Event)` values. Query `state()` and
 * `terminated()` to observe runtime status.
 */
template <typename Callbacks>
class {{ type_prefix }}Machine {
public:
  explicit {{ type_prefix }}Machine(Callbacks& callbacks)
    : callbacks_(&callbacks) {
    reset();
  }

  void reset() {
    terminated_ = false;
{% if reset_lines %}
{% for line in reset_lines %}
    {{ line }}
{% endfor %}
{% else %}
    (void)0;
{% endif %}
  }

  void start() {
    if (terminated_ || started_) {
      return;
    }
    started_ = true;
{% if has_start_target %}
    {{ start_transition_line }}
    {{ start_state_line }}
{% for line in start_lines %}
    {{ line }}
{% endfor %}
{% else %}
{% for line in fallback_lines %}
    {{ line }}
{% endfor %}
{% endif %}
  }

  {{ type_prefix }}State state() const { return current_state_; }
  bool terminated() const { return terminated_; }

  void dispatch({{ type_prefix }}Event event) {
    if (terminated_) {
      return;
    }
    if (!started_) {
      start();
      if (!started_) {
        return;
      }
    }
    on_event(current_state_, event);
    switch (current_state_) {
{% for state in state_cases %}
      case {{ state.case_label }}:
        handle_{{ state.handler_name }}(event);
        return;
{% endfor %}
      case {{ pseudo_initial_literal }}:
      case {{ pseudo_final_literal }}:
        return;
    }
  }

private:
{% for state in state_cases %}
  void handle_{{ state.handler_name }}({{ type_prefix }}Event event) {
{% if state.cpp_events %}
    switch (event) {
{% for event in state.cpp_events %}
{% for label in event.case_labels %}
      case {{ label }}:
{% endfor %}
      {
{% for line in event.lines %}
{{ line }}
{% endfor %}
      }
{% endfor %}
      default: {
        return;
      }
    }
{% else %}
    (void)event;
    return;
{% endif %}
  }
{% endfor %}

  Callbacks* callbacks_ = nullptr;
  {{ type_prefix }}State current_state_ = {{ pseudo_initial_literal }};
  bool started_ = false;
  bool terminated_ = false;
};
