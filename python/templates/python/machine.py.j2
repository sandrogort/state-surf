# Generated by StateSurf minimal generator (v1 subset). Python implementation.
from __future__ import annotations

from enum import Enum


class {{ type_prefix }}State(Enum):
    {{ pseudo_initial }} = "{{ pseudo_initial }}"
{% for state in states %}
    {{ state }} = "{{ state }}"
{% endfor %}
    {{ pseudo_final }} = "{{ pseudo_final }}"


class {{ type_prefix }}Event(Enum):
{% for event in events %}
    {{ event }} = "{{ event }}"
{% endfor %}


class {{ type_prefix }}GuardId(Enum):
{% for guard in guard_ids %}
    {{ guard }} = "{{ guard }}"
{% endfor %}


class {{ type_prefix }}ActionId(Enum):
{% for action in action_ids %}
    {{ action }} = "{{ action }}"
{% endfor %}


class {{ type_prefix }}Callbacks:
    def on_entry(self, state: {{ type_prefix }}State) -> None:
        raise NotImplementedError

    def on_exit(self, state: {{ type_prefix }}State) -> None:
        raise NotImplementedError

    def guard(self, state: {{ type_prefix }}State, event: {{ type_prefix }}Event, guard: {{ type_prefix }}GuardId) -> bool:
        raise NotImplementedError

    def action(self, state: {{ type_prefix }}State, event: {{ type_prefix }}Event, action: {{ type_prefix }}ActionId) -> None:
        raise NotImplementedError


def on_event(state: {{ type_prefix }}State, event: {{ type_prefix }}Event) -> None:
    return None


def on_transition(src: {{ type_prefix }}State, dst: {{ type_prefix }}State, event: {{ type_prefix }}Event) -> None:
    return None


class {{ type_prefix }}Machine:
    def __init__(self, callbacks: {{ type_prefix }}Callbacks) -> None:
        self._callbacks = callbacks
        self._state = {{ pseudo_initial_literal }}
        self._started = False
        self._terminated = False
        self.reset()

    def reset(self) -> None:
        self._terminated = False
{% if reset_lines %}
{% for line in reset_lines %}
        {{ line }}
{% endfor %}
{% else %}
        pass
{% endif %}

    def start(self) -> None:
        if self._terminated or self._started:
            return
        self._started = True
{% if has_start_target %}
        {{ start_transition_line }}
        {{ start_state_line }}
{% for line in start_lines %}
        {{ line }}
{% endfor %}
{% else %}
{% for line in fallback_lines %}
        {{ line }}
{% endfor %}
{% endif %}

    def state(self) -> {{ type_prefix }}State:
        return self._state

    def terminated(self) -> bool:
        return self._terminated

    def dispatch(self, event: {{ type_prefix }}Event) -> None:
        if self._terminated:
            return
        if not self._started:
            self.start()
            if not self._started:
                return
        on_event(self._state, event)
{% if state_cases %}
{% for state in state_cases %}
        {{ 'if' if loop.first else 'elif' }} self._state == {{ state.case_label }}:
{% if state.events %}
{% for event in state.events %}
            {{ 'if' if loop.first else 'elif' }} event == {{ event.case_label }}:
{% for line in event.lines %}
{{ '  ' + line }}
{% endfor %}
{% endfor %}
            else:
                return
{% else %}
            return
{% endif %}
{% endfor %}
        elif self._state == {{ pseudo_initial_literal }}:
            return
        elif self._state == {{ pseudo_final_literal }}:
            return
        else:
            return
{% else %}
        if self._state == {{ pseudo_initial_literal }}:
            return
        if self._state == {{ pseudo_final_literal }}:
            return
{% endif %}

    def _default_event(self) -> {{ type_prefix }}Event:
{% if default_event_variant %}
        return {{ type_prefix }}Event.{{ default_event_variant }}
{% else %}
        raise RuntimeError("No events defined for machine")
{% endif %}
