# Generated by StateSurf simulator scaffolding.
from __future__ import annotations

import importlib.util
import queue
import subprocess
import sys
import threading
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, List, Optional

from fastapi.responses import FileResponse
from nicegui import app, ui

BASE_DIR = Path(__file__).parent
MODULE_NAME = {{ machine_module_alias | tojson }}
MACHINE_FILE = BASE_DIR / {{ machine_module_filename | tojson }}

spec = importlib.util.spec_from_file_location(MODULE_NAME, MACHINE_FILE)
if spec is None or spec.loader is None:
    raise RuntimeError(f"Failed to load machine module from {MACHINE_FILE}")
machine_module = importlib.util.module_from_spec(spec)
sys.modules[MODULE_NAME] = machine_module
spec.loader.exec_module(machine_module)

{{ machine_name }} = getattr(machine_module, {{ machine_name | tojson }})
{{ type_prefix }}Callbacks = getattr(machine_module, {{ (type_prefix + 'Callbacks') | tojson }})
{{ type_prefix }}ActionId = getattr(machine_module, {{ (type_prefix + 'ActionId') | tojson }})
{{ type_prefix }}Event = getattr(machine_module, {{ (type_prefix + 'Event') | tojson }})
{{ type_prefix }}GuardId = getattr(machine_module, {{ (type_prefix + 'GuardId') | tojson }})
{{ type_prefix }}State = getattr(machine_module, {{ (type_prefix + 'State') | tojson }})

PLANTUML_CMD = {{ plantuml_cmd | tojson }}
MODEL_FILENAME = {{ puml_filename | tojson }}
EVENT_OPTIONS: List[str] = [
{% for name in event_names %}
    {{ (name) | tojson }},
{% endfor %}
]
EVENT_MAP = {
{% for name in event_names %}
    {{ (name) | tojson }}: {{ type_prefix }}Event.{{ name }},
{% endfor %}
}


@dataclass
class GuardRequest:
    state: {{ type_prefix }}State
    event: {{ type_prefix }}Event
    guard: {{ type_prefix }}GuardId
    response: "queue.Queue[bool]"


class SimulationContext:
    def __init__(self) -> None:
        self.machine = {{ machine_name }}(SimulatorCallbacks(self))
        self.lock = threading.Lock()
        self.guard_event = threading.Event()
        self.refresh_event = threading.Event()
        self.guard_request: Optional[GuardRequest] = None
        self.history_lines: List[str] = []
        self.replay_records: List[Dict[str, object]] = []
        self.reaction_active = False
        self.reaction_initial_state: Optional[{{ type_prefix }}State] = None
        self.current_event: Optional[{{ type_prefix }}Event] = None
        self.cursor = -1
        self.last_error: Optional[str] = None
        self.image_version = 0
        self.base_puml = BASE_DIR / MODEL_FILENAME
        self.active_puml = BASE_DIR / "_sim_highlight.puml"
        self.active_png = BASE_DIR / "_sim_highlight.png"
        self.history_lines.append(f"INIT state={self.machine.state().name}")

    def mark_dirty(self) -> None:
        self.refresh_event.set()

    def append_history(self, line: str) -> None:
        with self.lock:
            self.history_lines.append(line)
        self.mark_dirty()

    def start_reaction(self, event: Optional[{{ type_prefix }}Event]) -> bool:
        with self.lock:
            if self.reaction_active:
                return False
            self.reaction_active = True
            self.replay_records = []
            self.cursor = -1
            self.reaction_initial_state = self.machine.state()
            self.current_event = event
        label = event.name if event is not None else "start"
        self.append_history(
            f"EVENT {label} from={self.reaction_initial_state.name}"
        )
        return True

    def finish_reaction(self) -> None:
        with self.lock:
            if not self.reaction_active:
                return
            from_state = self.reaction_initial_state
            to_state = self.machine.state()
            record = {
                "kind": "state",
                "from_state": from_state.name if from_state else None,
                "to_state": to_state.name,
            }
            self.replay_records.append(record)
            self.reaction_active = False
            self.reaction_initial_state = None
            self.current_event = None
        self.append_history(
            f"STATE {record['from_state']} -> {record['to_state']}"
        )
        self.render_highlight()

    def add_record(self, record: Dict[str, object]) -> None:
        with self.lock:
            if self.reaction_active:
                self.replay_records.append(record)
        self.append_history(self.format_record(record))

    def format_record(self, record: Dict[str, object]) -> str:
        kind = record.get("kind")
        if kind == "entry":
            return f"ENTRY state={record['state']}"
        if kind == "exit":
            return f"EXIT state={record['state']}"
        if kind == "action":
            return (
                f"ACTION state={record['state']} event={record['event']}"
                f" action={record['action']}"
            )
        if kind == "guard":
            return (
                f"GUARD state={record['state']} event={record['event']}"
                f" guard={record['guard']} -> {record['decision']}"
            )
        if kind == "state":
            return (
                f"STATE {record.get('from_state')} -> {record.get('to_state')}"
            )
        return f"INFO {record}"

    def request_guard(self, state: {{ type_prefix }}State, event: {{ type_prefix }}Event, guard: {{ type_prefix }}GuardId) -> bool:
        response_queue: "queue.Queue[bool]" = queue.Queue()
        req = GuardRequest(state=state, event=event, guard=guard, response=response_queue)
        with self.lock:
            self.guard_request = req
        self.guard_event.set()
        decision = response_queue.get()
        self.add_record(
            {
                "kind": "guard",
                "state": state.name,
                "event": event.name,
                "guard": guard.name,
                "decision": decision,
            }
        )
        return decision

    def pop_guard_request(self) -> Optional[GuardRequest]:
        with self.lock:
            req = self.guard_request
            self.guard_request = None
        if req is None:
            return None
        self.guard_event.clear()
        return req

    def current_state_after_cursor(self) -> {{ type_prefix }}State:
        with self.lock:
            state = self.reaction_initial_state or self.machine.state()
            if self.cursor < 0:
                return state or self.machine.state()
            state_tracker = self.reaction_initial_state or self.machine.state()
            for idx, item in enumerate(self.replay_records):
                if idx > self.cursor:
                    break
                if item.get("kind") == "state":
                    to_state = item.get("to_state")
                    if to_state:
                        state_tracker = {{ type_prefix }}State[to_state]
            return state_tracker or self.machine.state()

    def render_highlight(self) -> None:
        try:
            overlay = self.build_highlight_overlay()
            base_text = self.base_puml.read_text(encoding="utf-8")
            lines = base_text.splitlines()
            insert_at = len(lines)
            for idx in range(len(lines) - 1, -1, -1):
                if lines[idx].strip().lower() == "@enduml":
                    insert_at = idx
                    break
            new_lines = lines[:insert_at] + overlay + lines[insert_at:]
            self.active_puml.write_text("\n".join(new_lines) + "\n", encoding="utf-8")
            result = subprocess.run(
                [PLANTUML_CMD, "-tpng", str(self.active_puml)],
                cwd=str(BASE_DIR),
                check=False,
                capture_output=True,
                text=True,
            )
            if result.returncode != 0:
                if "No such file or directory" in (result.stderr or ""):
                    self.last_error = (
                        f"PlantUML command '{PLANTUML_CMD}' not found. Install PlantUML or update the --plantuml option."
                    )
                else:
                    self.last_error = (
                        "PlantUML rendering failed: "
                        + (result.stderr.strip() or result.stdout.strip())
                    )
            else:
                self.last_error = None
                self.image_version += 1
        except FileNotFoundError:
            self.last_error = (
                f"PlantUML command '{PLANTUML_CMD}' not found. Install PlantUML or update the --plantuml option."
            )
        except Exception as exc:  # pragma: no cover - defensive
            self.last_error = f"Failed to update PlantUML diagram: {exc}"
        finally:
            self.mark_dirty()

    def build_highlight_overlay(self) -> List[str]:
        with self.lock:
            records = list(self.replay_records)
            cursor = self.cursor
            event = self.current_event
            initial_state = self.reaction_initial_state
            current_machine_state = self.machine.state()

        current_state = initial_state or current_machine_state
        record: Optional[Dict[str, object]] = None
        entries: List[str] = []
        exits: List[str] = []

        if cursor >= 0 and cursor < len(records):
            for idx, item in enumerate(records):
                if idx == cursor:
                    record = item
                if item.get("kind") == "state":
                    to_state = item.get("to_state")
                    if to_state:
                        current_state = {{ type_prefix }}State[to_state]
                if idx >= cursor:
                    break
        else:
            # apply any state records to reflect latest machine state
            for item in records:
                if item.get("kind") == "state":
                    to_state = item.get("to_state")
                    if to_state:
                        current_state = {{ type_prefix }}State[to_state]

        if record:
            kind = record.get("kind")
            if kind == "entry":
                entries.append(str(record.get("state")))
            elif kind == "exit":
                exits.append(str(record.get("state")))

        highlight_state = current_state.name

        overlay: List[str] = ["' ---- StateSurf simulation highlight ----"]
        overlay.append("skinparam backgroundColor White")
        overlay.append("skinparam stateBorderColor Black")
        for st in exits:
            overlay.append(f'state "{st}" #FFCDD2')
        for st in entries:
            overlay.append(f'state "{st}" #BBDEFB')
        overlay.append(f'state "{highlight_state}" #C8E6C9')

        note_lines: List[str] = ["note as __StateSurfNote"]
        note_lines.append(f"State: {highlight_state}")
        if event is not None:
            note_lines.append(f"Event: {event.name}")
        if record:
            kind = record.get("kind")
            if kind == "action":
                note_lines.append(
                    f"Action: {record.get('action')} (state {record.get('state')})"
                )
            elif kind in ("entry", "exit"):
                note_lines.append(f"{kind.title()} state {record.get('state')}")
            elif kind == "guard":
                note_lines.append(
                    "Guard "
                    + f"{record.get('guard')} -> {record.get('decision')}"
                )
            elif kind == "state":
                note_lines.append(
                    f"Transition: {record.get('from_state')} -> {record.get('to_state')}"
                )
        note_lines.append("end note")
        overlay.extend(note_lines)
        return overlay

    def step_next(self) -> None:
        with self.lock:
            if not self.replay_records:
                return
            if self.cursor < len(self.replay_records) - 1:
                self.cursor += 1
        self.render_highlight()

    def run_to_end(self) -> None:
        with self.lock:
            if not self.replay_records:
                return
            self.cursor = len(self.replay_records) - 1
        self.render_highlight()

    def reset_cursor(self) -> None:
        with self.lock:
            self.cursor = -1
        self.render_highlight()

    def dispatch(self, event_name: str) -> None:
        event = EVENT_MAP.get(event_name)
        if event is None:
            self.append_history(f"WARN Unknown event {event_name}")
            return
        if not self.start_reaction(event):
            self.append_history("WARN Reaction already in progress")
            return

        def worker() -> None:
            try:
                self.machine.dispatch(event)
            finally:
                self.finish_reaction()

        threading.Thread(target=worker, daemon=True).start()

    def start_machine(self) -> None:
        if not self.start_reaction(None):
            self.append_history("WARN Reaction already in progress")
            return

        def worker() -> None:
            try:
                self.machine.start()
            finally:
                self.finish_reaction()

        threading.Thread(target=worker, daemon=True).start()

    def reset_machine(self) -> None:
        with self.lock:
            self.replay_records = []
            self.cursor = -1
            self.reaction_active = False
            self.reaction_initial_state = None
            self.current_event = None
        self.machine.reset()
        self.append_history(f"RESET state={self.machine.state().name}")
        self.render_highlight()


class SimulatorCallbacks({{ type_prefix }}Callbacks):
    def __init__(self, ctx: SimulationContext) -> None:
        self.ctx = ctx

    def on_entry(self, state: {{ type_prefix }}State) -> None:
        self.ctx.add_record({"kind": "entry", "state": state.name})

    def on_exit(self, state: {{ type_prefix }}State) -> None:
        self.ctx.add_record({"kind": "exit", "state": state.name})

    def guard(
        self,
        state: {{ type_prefix }}State,
        event: {{ type_prefix }}Event,
        guard: {{ type_prefix }}GuardId,
    ) -> bool:
        return self.ctx.request_guard(state, event, guard)

    def action(
        self,
        state: {{ type_prefix }}State,
        event: {{ type_prefix }}Event,
        action: {{ type_prefix }}ActionId,
    ) -> None:
        self.ctx.add_record(
            {
                "kind": "action",
                "state": state.name,
                "event": event.name,
                "action": action.name,
            }
        )


ctx = SimulationContext()


@app.get("/sim/highlight.png")
async def serve_highlight_png() -> FileResponse:
    # Disable caching so the simulator always shows the latest rendering.
    return FileResponse(
        ctx.active_png,
        headers={"Cache-Control": "no-store, max-age=0", "Pragma": "no-cache"},
    )


app.add_static_files("/sim", str(BASE_DIR))


def update_history(history_box: ui.textarea) -> None:
    if not ctx.refresh_event.is_set():
        return
    ctx.refresh_event.clear()
    with ctx.lock:
        history_box.value = "\n".join(ctx.history_lines[-200:])
    if ctx.last_error:
        error_banner.text = ctx.last_error
        error_banner.visible = True
    else:
        error_banner.visible = False
    diagram_source = f"/sim/highlight.png?t={ctx.image_version}"
    diagram.set_source(diagram_source)


def update_guard_prompt() -> None:
    req = ctx.guard_request
    if req is None:
        guard_panel.visible = False
        return
    guard_label.text = (
        f"Guard {req.guard.name} in state {req.state.name} on event {req.event.name}"
    )
    guard_panel.visible = True


def guard_decision(decision: bool) -> None:
    req = ctx.pop_guard_request()
    if req is None:
        guard_panel.visible = False
        return
    req.response.put(decision)
    guard_panel.visible = False


with ui.splitter().classes("h-full w-full") as layout_splitter:
    with layout_splitter.before:
        with ui.column().classes("gap-4 w-full"):
            with ui.row().classes("items-center"):
                ui.label("StateSurf Simulator").classes("text-2xl font-bold")

            error_banner = ui.label("").classes("text-negative")
            error_banner.visible = False

            with ui.row().classes("gap-2"):
                ui.button("Start", on_click=lambda: ctx.start_machine())
                ui.button("Reset", on_click=lambda: ctx.reset_machine())
                event_select = ui.select(
                    options=EVENT_OPTIONS,
                    label="Event",
                )
                if EVENT_OPTIONS:
                    event_select.value = EVENT_OPTIONS[0]
                else:
                    event_select.disable()
                dispatch_button = ui.button(
                    "Dispatch",
                    on_click=lambda: ctx.dispatch(event_select.value) if event_select.value else None,
                )
                if not EVENT_OPTIONS:
                    dispatch_button.disable()

            ui.separator()
            ui.label("History (recent)")

            history_box = ui.textarea().props("outlined readonly rows=10").classes("w-full")

            with ui.card().classes("w-full gap-4") as guard_panel:
                guard_label = ui.label("Guard evaluation")
                with ui.row().classes("gap-4"):
                    ui.button("True", on_click=lambda: guard_decision(True)).classes("bg-positive text-white")
                    ui.button("False", on_click=lambda: guard_decision(False)).classes("bg-negative text-white")

    with layout_splitter.after:
        diagram = ui.image("/sim/highlight.png").style("width: 100%; height: 100%; object-fit: contain; border: 1px solid #ccc;")

guard_panel.visible = False

ui.timer(0.25, lambda: update_history(history_box))
ui.timer(0.25, update_guard_prompt)

ctx.render_highlight()

ui.run(reload=False)
