#pragma once
// Generated by StateSurf minimal generator (v1 subset). C++11 header-only.
enum class FsmState {
  InitialPseudoState,
  State1,
  State2,
  State3,
  State4,
  State5,
  FinalPseudoState
};

enum class FsmEvent {
  eventA,
  eventB,
  eventC,
  eventD,
  eventFoo,
  init
};

enum class FsmGuardId {
  guardA,
  guardB
};

enum class FsmActionId {
  actionA,
  actionB
};

inline void on_event(FsmState, FsmEvent) {}
inline void on_transition(FsmState, FsmState, FsmEvent) {}

/**
 * @brief Deterministic state machine generated from a PlantUML model.
 *
 * The `Callbacks` type argument must provide:
 *   - `void on_entry(FsmState)` invoked on every state entry
 *   - `void on_exit(FsmState)` invoked on every state exit
 *   - `bool guard(FsmState, FsmEvent, FsmGuardId)` to resolve guard conditions
 *   - `void action(FsmState, FsmEvent, FsmActionId)` for transition side-effects
 *
 * Hold a callbacks instance for any required application state and pass it
 * into the constructor. Call `start()` to trigger the initial transition (or
 * let the first `dispatch` call do it lazily), then drive the machine with
 * `dispatch(FsmEvent)` values. Query `state()` and
 * `terminated()` to observe runtime status.
 */
template <typename Callbacks>
class FsmMachine {
public:
  explicit FsmMachine(Callbacks& callbacks) : callbacks_(callbacks) { reset(); }

  void reset() {
    terminated_ = false;
    started_ = false;
    s_ = FsmState::InitialPseudoState;
  }

  void start() {
    if (terminated_ || started_) return;
    started_ = true;
    on_transition(FsmState::InitialPseudoState, FsmState::State1, FsmEvent{});
    s_ = FsmState::State1;
    callbacks_.on_entry(FsmState::State1);
  }

  FsmState state() const { return s_; }
  bool terminated() const { return terminated_; }

  void dispatch(FsmEvent e) {
    if (terminated_) return;
    if (!started_) {
      start();
      if (!started_) return;
    }
    on_event(s_, e);
    switch (s_) {
      case FsmState::State1: {
        switch (e) {
          case FsmEvent::eventA: {
            on_transition(s_, FsmState::State2, e);
            callbacks_.on_exit(FsmState::State1);
            callbacks_.on_entry(FsmState::State2);
            s_ = FsmState::State2;
            return;
          }
          case FsmEvent::init: {
            on_transition(s_, s_, e);
            return;
          }
          case FsmEvent::eventFoo: {
            on_transition(s_, s_, e);
            return;
          }
          default: return;
        }
      }
      case FsmState::State2: {
        switch (e) {
          case FsmEvent::eventB: {
            if (callbacks_.guard(s_, e, FsmGuardId::guardA)) {
              on_transition(s_, FsmState::State3, e);
              callbacks_.on_exit(FsmState::State2);
              callbacks_.on_entry(FsmState::State3);
              s_ = FsmState::State3;
              return;
            }
            return;
          }
          default: return;
        }
      }
      case FsmState::State3: {
        switch (e) {
          case FsmEvent::eventC: {
            on_transition(s_, FsmState::State4, e);
            callbacks_.on_exit(FsmState::State3);
            callbacks_.action(s_, e, FsmActionId::actionA);
            callbacks_.on_entry(FsmState::State4);
            s_ = FsmState::State4;
            return;
          }
          default: return;
        }
      }
      case FsmState::State4: {
        switch (e) {
          case FsmEvent::eventD: {
            if (callbacks_.guard(s_, e, FsmGuardId::guardB)) {
              on_transition(s_, FsmState::State5, e);
              callbacks_.on_exit(FsmState::State4);
              callbacks_.action(s_, e, FsmActionId::actionB);
              callbacks_.on_entry(FsmState::State5);
              s_ = FsmState::State5;
              return;
            }
            return;
          }
          default: return;
        }
      }
      case FsmState::State5: {
        switch (e) {
          case FsmEvent::init: {
            on_transition(s_, s_, e);
            return;
          }
          default: return;
        }
      }
      case FsmState::InitialPseudoState: {
        return;
      }
      case FsmState::FinalPseudoState: {
        return;
      }
    }
  }

private:
  Callbacks& callbacks_;
  FsmState s_;
  bool started_ = false;
  bool terminated_ = false;
};