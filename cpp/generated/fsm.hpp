#pragma once
// Generated by StateSurf minimal generator (v1 subset). C++11 header-only.
enum class FsmState {
  InitialPseudoState,
  State1,
  State2,
  State3,
  State4,
  State5,
  FinalPseudoState
};

enum class FsmEvent {
  eventA,
  eventB,
  eventC,
  eventD,
  eventFoo,
  init
};

enum class FsmGuardId {
  guardA,
  guardB
};

enum class FsmActionId {
  actionA,
  actionB
};

struct FsmCallbacks {
  virtual ~FsmCallbacks() {}
  virtual void on_entry(FsmState) = 0;
  virtual void on_exit(FsmState) = 0;
  virtual bool guard(FsmState, FsmEvent, FsmGuardId) = 0;
  virtual void action(FsmState, FsmEvent, FsmActionId) = 0;
};

inline void on_event(FsmState, FsmEvent) {}
inline void on_transition(FsmState, FsmState, FsmEvent) {}

class FsmMachine {
public:
  explicit FsmMachine(FsmCallbacks& callbacks) : callbacks_(callbacks) { reset(); }

  void reset() {
    terminated_ = false;
    started_ = false;
    s_ = FsmState::InitialPseudoState;
  }

  void start() {
    if (terminated_ || started_) return;
    started_ = true;
    on_transition(FsmState::InitialPseudoState, FsmState::State1, FsmEvent{});
    s_ = FsmState::State1;
    callbacks_.on_entry(FsmState::State1);
  }

  FsmState state() const { return s_; }
  bool terminated() const { return terminated_; }

  void dispatch(FsmEvent e) {
    if (terminated_) return;
    if (!started_) {
      start();
      if (!started_) return;
    }
    on_event(s_, e);
    switch (s_) {
      case FsmState::State1: {
        switch (e) {
          case FsmEvent::eventA: {
            on_transition(s_, FsmState::State2, e);
            callbacks_.on_exit(FsmState::State1);
            callbacks_.on_entry(FsmState::State2);
            s_ = FsmState::State2;
            return;
          }
          case FsmEvent::init: {
            on_transition(s_, s_, e);
            return;
          }
          case FsmEvent::eventFoo: {
            on_transition(s_, s_, e);
            return;
          }
          default: return;
        }
      }
      case FsmState::State2: {
        switch (e) {
          case FsmEvent::eventB: {
            if (callbacks_.guard(s_, e, FsmGuardId::guardA)) {
              on_transition(s_, FsmState::State3, e);
              callbacks_.on_exit(FsmState::State2);
              callbacks_.on_entry(FsmState::State3);
              s_ = FsmState::State3;
              return;
            }
            return;
          }
          default: return;
        }
      }
      case FsmState::State3: {
        switch (e) {
          case FsmEvent::eventC: {
            on_transition(s_, FsmState::State4, e);
            callbacks_.on_exit(FsmState::State3);
            callbacks_.action(s_, e, FsmActionId::actionA);
            callbacks_.on_entry(FsmState::State4);
            s_ = FsmState::State4;
            return;
          }
          default: return;
        }
      }
      case FsmState::State4: {
        switch (e) {
          case FsmEvent::eventD: {
            if (callbacks_.guard(s_, e, FsmGuardId::guardB)) {
              on_transition(s_, FsmState::State5, e);
              callbacks_.on_exit(FsmState::State4);
              callbacks_.action(s_, e, FsmActionId::actionB);
              callbacks_.on_entry(FsmState::State5);
              s_ = FsmState::State5;
              return;
            }
            return;
          }
          default: return;
        }
      }
      case FsmState::State5: {
        switch (e) {
          case FsmEvent::init: {
            on_transition(s_, s_, e);
            return;
          }
          default: return;
        }
      }
      case FsmState::InitialPseudoState: {
        return;
      }
      case FsmState::FinalPseudoState: {
        return;
      }
    }
  }

private:
  FsmCallbacks& callbacks_;
  FsmState s_;
  bool started_ = false;
  bool terminated_ = false;
};