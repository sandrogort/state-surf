#pragma once
// Generated by StateSurf minimal generator (v1 subset). C++11 header-only.
namespace statesurf {

enum class State {
  InitialPseudoState,
  State1,
  State2,
  State3,
  State4,
  State5,
  FinalPseudoState
};

enum class Event {
  eventA,
  eventB,
  eventC,
  eventD,
  eventFoo,
  init
};

enum class GuardId {
  guardA,
  guardB
};

enum class ActionId {
  actionA,
  actionB
};

struct IHooks {
  virtual ~IHooks() {}
  virtual void on_entry(State) = 0;
  virtual void on_exit(State) = 0;
  virtual bool guard(State, Event, GuardId) = 0;
  virtual void action(State, Event, ActionId) = 0;
};

inline void on_event(State, Event) {}
inline void on_transition(State, State, Event) {}

class StateSurfMachine {
public:
  explicit StateSurfMachine(IHooks& impl) : impl_(impl) { reset(); }

  void reset() {
    terminated_ = false;
    started_ = false;
    s_ = State::InitialPseudoState;
  }

  void start() {
    if (terminated_ || started_) return;
    started_ = true;
    on_transition(State::InitialPseudoState, State::State1, Event{});
    s_ = State::State1;
    impl_.on_entry(State::State1);
  }

  State state() const { return s_; }
  bool terminated() const { return terminated_; }

  void dispatch(Event e) {
    if (terminated_) return;
    if (!started_) {
      start();
      if (!started_) return;
    }
    on_event(s_, e);
    switch (s_) {
      case State::State1: {
        switch (e) {
          case Event::eventA: {
            {
              on_transition(s_, State::State2, e);
              impl_.on_exit(State::State1);
              impl_.on_entry(State::State2);
              s_ = State::State2;
              return;
            }
          }
          case Event::init: {
            {
              on_transition(s_, s_, e);
              return;
            }
          }
          case Event::eventFoo: {
            {
              on_transition(s_, s_, e);
              return;
            }
          }
          default: return;
        }
      }
      case State::State2: {
        switch (e) {
          case Event::eventB: {
            if (impl_.guard(s_, e, GuardId::guardA)) {
              on_transition(s_, State::State3, e);
              impl_.on_exit(State::State2);
              impl_.on_entry(State::State3);
              s_ = State::State3;
              return;
            }
            return;
          }
          default: return;
        }
      }
      case State::State3: {
        switch (e) {
          case Event::eventC: {
            {
              on_transition(s_, State::State4, e);
              impl_.on_exit(State::State3);
              impl_.action(s_, e, ActionId::actionA);
              impl_.on_entry(State::State4);
              s_ = State::State4;
              return;
            }
          }
          default: return;
        }
      }
      case State::State4: {
        switch (e) {
          case Event::eventD: {
            if (impl_.guard(s_, e, GuardId::guardB)) {
              on_transition(s_, State::State5, e);
              impl_.on_exit(State::State4);
              impl_.action(s_, e, ActionId::actionB);
              impl_.on_entry(State::State5);
              s_ = State::State5;
              return;
            }
            return;
          }
          default: return;
        }
      }
      case State::State5: {
        switch (e) {
          case Event::init: {
            {
              on_transition(s_, s_, e);
              return;
            }
          }
          default: return;
        }
      }
      case State::InitialPseudoState: {
        return;
      }
      case State::FinalPseudoState: {
        return;
      }
    }
  }

private:
  IHooks& impl_;
  State s_;
  bool started_ = false;
  bool terminated_ = false;
};

} // namespace statesurf