#pragma once
// Generated by StateSurf minimal generator (v1 subset). C++11 header-only.
#include <cstdint>

enum class FsmState : std::uint8_t {
  InitialPseudoState,
  State1,
  State2,
  State3,
  State4,
  State5,
  FinalPseudoState
};

enum class FsmEvent : std::uint8_t {
  eventA,
  eventB,
  eventC,
  eventD,
  eventFoo,
  init
};

enum class FsmGuardId : std::uint8_t {
  guardA,
  guardB
};

enum class FsmActionId : std::uint8_t {
  actionA,
  actionB
};

struct FsmTransition {
  FsmState from_state;
  FsmState to_state;
};

inline void on_event(FsmState current_state, FsmEvent event) {
  (void)current_state;
  (void)event;
}

inline void on_transition(
  FsmTransition transition,
  FsmEvent event
) {
  (void)transition;
  (void)event;
}

/**
 * @brief Deterministic state machine generated from a PlantUML model.
 *
 * The `Callbacks` type argument must provide:
 *   - `void on_entry(FsmState)` invoked on every state entry
 *   - `void on_exit(FsmState)` invoked on every state exit
 *   - `bool guard(FsmState, FsmEvent, FsmGuardId)` to resolve guard conditions
 *   - `void action(FsmState, FsmEvent, FsmActionId)` for transition side-effects
 *
 * Hold a callbacks instance for any required application state and pass it
 * into the constructor. Call `start()` to trigger the initial transition (or
 * let the first `dispatch` call do it lazily), then drive the machine with
 * `dispatch(FsmEvent)` values. Query `state()` and
 * `terminated()` to observe runtime status.
 */
template <typename Callbacks>
class FsmMachine {
public:
  explicit FsmMachine(Callbacks& callbacks)
    : callbacks_(&callbacks) {
    reset();
  }

  void reset() {
    terminated_ = false;
    started_ = false;
    current_state_ = FsmState::InitialPseudoState;
  }

  void start() {
    if (terminated_ || started_) {
      return;
    }
    started_ = true;
    on_transition(FsmTransition{FsmState::InitialPseudoState, FsmState::State1}, FsmEvent{});
    current_state_ = FsmState::State1;
    callbacks_->on_entry(FsmState::State1);
  }

  FsmState state() const { return current_state_; }
  bool terminated() const { return terminated_; }

  void dispatch(FsmEvent event) {
    if (terminated_) {
      return;
    }
    if (!started_) {
      start();
      if (!started_) {
        return;
      }
    }
    on_event(current_state_, event);
    switch (current_state_) {
      case FsmState::State1:
        handle_State1(event);
        return;
      case FsmState::State2:
        handle_State2(event);
        return;
      case FsmState::State3:
        handle_State3(event);
        return;
      case FsmState::State4:
        handle_State4(event);
        return;
      case FsmState::State5:
        handle_State5(event);
        return;
      case FsmState::InitialPseudoState:
      case FsmState::FinalPseudoState:
        return;
    }
  }

private:
  void handle_State1(FsmEvent event) {
    switch (event) {
      case FsmEvent::eventA:
      {
            on_transition(FsmTransition{current_state_, FsmState::State2}, event);
            callbacks_->on_exit(FsmState::State1);
            callbacks_->on_entry(FsmState::State2);
            current_state_ = FsmState::State2;
            return;
      }
      case FsmEvent::init:
      case FsmEvent::eventFoo:
      {
            on_transition(FsmTransition{current_state_, current_state_}, event);
            return;
      }
      default: {
        return;
      }
    }
  }
  void handle_State2(FsmEvent event) {
    switch (event) {
      case FsmEvent::eventB:
      {
            if (callbacks_->guard(current_state_, event, FsmGuardId::guardA)) {
              on_transition(FsmTransition{current_state_, FsmState::State3}, event);
              callbacks_->on_exit(FsmState::State2);
              callbacks_->on_entry(FsmState::State3);
              current_state_ = FsmState::State3;
              return;
            }
            return;
      }
      default: {
        return;
      }
    }
  }
  void handle_State3(FsmEvent event) {
    switch (event) {
      case FsmEvent::eventC:
      {
            on_transition(FsmTransition{current_state_, FsmState::State4}, event);
            callbacks_->on_exit(FsmState::State3);
            callbacks_->action(current_state_, event, FsmActionId::actionA);
            callbacks_->on_entry(FsmState::State4);
            current_state_ = FsmState::State4;
            return;
      }
      default: {
        return;
      }
    }
  }
  void handle_State4(FsmEvent event) {
    switch (event) {
      case FsmEvent::eventD:
      {
            if (callbacks_->guard(current_state_, event, FsmGuardId::guardB)) {
              on_transition(FsmTransition{current_state_, FsmState::State5}, event);
              callbacks_->on_exit(FsmState::State4);
              callbacks_->action(current_state_, event, FsmActionId::actionB);
              callbacks_->on_entry(FsmState::State5);
              current_state_ = FsmState::State5;
              return;
            }
            return;
      }
      default: {
        return;
      }
    }
  }
  void handle_State5(FsmEvent event) {
    switch (event) {
      case FsmEvent::init:
      {
            on_transition(FsmTransition{current_state_, current_state_}, event);
            return;
      }
      default: {
        return;
      }
    }
  }

  Callbacks* callbacks_ = nullptr;
  FsmState current_state_ = FsmState::InitialPseudoState;
  bool started_ = false;
  bool terminated_ = false;
};